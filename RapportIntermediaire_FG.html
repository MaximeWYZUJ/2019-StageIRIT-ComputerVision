<!DOCTYPE html>
<html>
<head>
<title>RapportIntermediaire_FG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>FENETRE GLISSANTE</h1>
<h2>Introduction : Déroulement de l'algorithme</h2>
<p>On dispose de deux images : un pattern issu d'une base de données et une image dans laquelle on veut savoir si l'on peut trouver ce pattern, et si oui à quel endroit. Pour faire cela, on crée une fenêtre que l'on va déplacer dans l'image. Après chaque déplacement, on mesure un score de corrélation entre la région de l'image à l'intérieur de la fenêtre, et le pattern que l'on veut identifier. Une fois que l'on a calculé tous les scores, on les trie et on ne garde que ceux dépassant un certain seuil.
Les coordonnées des fenêtres associées à ces scores sont les endroits où se trouvent le pattern.</p>
<p>Plusieurs questions se posent. Concernant la fenêtre, comment choisir sa taille et est-ce pertinant de parcourir toute l'image ? Comment se calcule le score de corrélation et quels critères permettent de déterminer la seuil permettant distinguer les bons et les mauvais scores ?</p>
<h2>Définition de la fenêtre glissante</h2>
<p>Pour trouver le pattern dans l'image, on veut aussi tirer partie du fait que, dans la plupart des jeux 2D, les éléments sont agencés sur une grille (<em>tilemap</em>) dont chaque case (tuile) est susceptible de contenir le pattern. Cette information nous permet de chercher le pattern à des emplacements prédéfinis, plutôt que de parcourir toute l'image pixel par pixel. En revanche, il nous faut connaître les coordonnées de la grille par rapport à l'image (<em>offsets</em>) et les dimensions d'une tuile, comme indiqué sur l'image ci-dessous. Evidemment, le gain de performances est énorme.</p>
<p><img src="https://imagizer.imageshack.com/img924/2880/zUgMrw.png" alt="tile map" /></p>
<p>Même si c'est souvent la même en pratique, en théorie les dimensions des éléments du jeu sont différentes de celles d'une tuile (on peut imaginer qu'un objet soit de dimension deux fois plus petite que la tuile et qu'il puisse se trouver aux quatre coins de celle-ci; en le cherchant au milieu on ne le trouvera jamais). De plus, les patterns de la base de données ne conservent pas leurs dimensions une fois rendus dans le jeu. Pour ces deux raisons, il nous faut l'information de <em>scaling</em> entre la base de données et l'image afin de redimensionner notre pattern aux dimensions de ce même pattern dans l'image. Ceci amène quelques erreurs d'interpolation qui restent négligeables.</p>
<p>Sur des cas simples où le pattern occupe toute la tuile, il nous faut donc 2 informations a priori : l'<em>offset</em> de la grille par rapport aux bords de l'image ainsi que le ratio entre le pattern de notre base de données et le pattern dans l'image. Dans des cas plus compliqués, il nous faut également les dimensions d'une tuile dans l'image. Pour l'instant, je n'ai traité que des cas simples.</p>
<h2>Mesure de la corrélation</h2>
<p>Une fois que l'on a positionné notre fenêtre sur une case de la grille, on peut comparer la sous-image correspondant à cette case avec notre pattern aux bonnes dimensions.</p>
<p>On commence donc pas créer un masque à partir du canal alpha du pattern. Ce masque nous permet de mesurer la corrélation uniquement entre les pixels utiles de notre pattern (ceux où il y a de la couleur). On peut ensuite mesurer la corrélation entre ces pixels utiles à l'aide de différentes mesures : L1, L2 ou ZNCC par exemple.</p>
<p>Les figures ci-dessous illustrent l'influence, sur ces mesures, du décalage entre la fenêtre et le pattern. On voit que si l'on applique la fenêtre précisémment où se trouve le pattern, les mesures arrivent à se distinguer. En revanche, le moindre pixel de décalage entraine de grosses erreurs de mesure. Comme on peut le voir sur la dernière figure, c'est la mesure L2 qui est la moins sensible aux décalages puisque entre 2 et 4 pixels de décalage, on peut toujours considérer le score comme correct.</p>
<p><img src="https://imagizer.imageshack.com/img922/2539/uggeLf.jpg" alt="L1 3D" /></p>
<blockquote>
<p>Mesure L1</p>
</blockquote>
<!--- --->
<p><img src="https://imagizer.imageshack.com/img923/8302/AZqWTA.jpg" alt="L2 3D" /></p>
<blockquote>
<p>Mesure L2</p>
</blockquote>
<!--- --->
<p><img src="https://imagizer.imageshack.com/img923/5179/hPdb6j.jpg" alt="ZNCC 3D" /></p>
<blockquote>
<p>Mesure ZNCC</p>
</blockquote>
<!--- --->
<p><img src="https://imagizer.imageshack.com/img923/4088/ycsOqs.jpg" alt="Decalage" /></p>
<blockquote>
<p>Mesures en fonction du nombre de pixels de décalage</p>
</blockquote>
<!--- --->
<h2>Résultats et pistes d'amélioration</h2>
<p>Les résultats obtenus sur des exemples simples où les éléments sont de même dimension que la tuile sont très satisfaisants.</p>
<p>Cependant, la qualité des résultats est très sensible à l'<em>offset</em> de la grille. J'ai remarqué que les éléments à trouver ne sont pas toujours au centre de la tuile, mais parfois décalés de quelques pixels. Or pour le moment je ne cherche qu'au centre de la tuile. Un moyen simple de palier à ce problème est de modifier ma base de données de patterns de sorte qu'ils soient décalés de la même manière que dans le jeu.</p>
<p><img src="https://imagizer.imageshack.com/img922/3246/5FjI1n.png" alt="Spice berry opti" />
<img src="https://imagizer.imageshack.com/img921/1762/bFWJ6H.png" alt="Spice berry decalage 2" /></p>
<blockquote>
<p>Détection des baies épicées avec un offset optimal, puis avec un offset décalé de 2 pixels par rapport à l'offset optimal.</p>
</blockquote>
<!--- --->
<p>On peut aussi filtrer simplement les cases qui n'ont rien à voir avec le pattern. En comparant les histogrammes du pattern et de chaque case de la grille, on peut seuiller afin de traiter uniquement les cases contenant plus ou moins les bonnes couleurs. En plus, cette méthode n'est quasiment pas impactée par le décalage.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
